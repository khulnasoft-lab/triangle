From: Arnaud Rebillout <arnaudr@kali.org>
Date: Tue, 7 Nov 2023 13:47:20 +0700
Subject: Dual: http: Make fallbacks respect the protocol

As a reminder, mirrorbits behaviour is as such:
- HTTP request : mirrorbits redirects to either HTTP or HTTPS
- HTTPS request: mirrorbits redirects to HTTPS

Before this commit, the fallback URLs were used "as is". This was
actually not perfect, for example if your fallback mirror is
http://foobar.org, then mirrorbits would happily redirect HTTPS request
to a HTTP fallback mirror...

Of course, the right thing to do is to specify only HTTPS fallback
mirrors, but it might not be obvious for everyone, especially since the
sample mirrorbits.conf doesn't mention that, and gives HTTP fallback
mirrors (http://fallback1.mirror/repo/) as an example.

With this commit, we change that a bit.

First, in the sample mirrorbits.conf, we mention that fallback mirrors
should support both HTTP and HTTPS (which, I think, is a reasonable
requirement).

Then, in the code, we now make the fallback selection a bit smarter,
possibly ignoring the protocol that was set by user in the conf:
- if WITHTLS: force HTTPS
- if WITHOUTLS: force HTTP
- otherwise: use the URL "as is"

This logic for the protocol selection is what's used already when
selecting mirrors, so basically this commit brings fallback mirrors in
lines with mirror selection.
---
 http/http.go    | 38 ++++++++++++++++++++++++++++++++++++--
 mirrorbits.conf |  2 ++
 2 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/http/http.go b/http/http.go
index fee5a9e..d4e25a4 100644
--- a/http/http.go
+++ b/http/http.go
@@ -257,13 +257,47 @@ func (h *HTTP) mirrorHandler(w http.ResponseWriter, r *http.Request, ctx *Contex
 		if len(fallbacks) > 0 {
 			fallback = true
 			for i, f := range fallbacks {
+				// Remove the scheme from the fallback url
+				hostPath := ""
+				idx := strings.Index(f.URL, "://")
+				if idx == -1 {
+					hostPath = f.URL
+				} else {
+					hostPath = f.URL[idx+3:]
+				}
+
+				// Now add the scheme according to the request
+				httpURL := ""
+				httpsURL := ""
+				proto := mirrors.UNDEFINED
+				switch ctx.SecureOption() {
+				case WITHTLS:
+					httpsURL = "https://" + hostPath
+					proto = mirrors.HTTPS
+				case WITHOUTTLS:
+					httpURL = "http://" + hostPath
+					proto = mirrors.HTTP
+				default:
+					// respect the original fallback url
+					if strings.HasPrefix(f.URL, "https") {
+						httpsURL = f.URL
+						proto = mirrors.HTTPS
+					} else {
+						httpURL = f.URL
+						proto = mirrors.HTTP
+					}
+				}
+
+				// Create a mirror object and add it to the result
 				mlist = append(mlist, mirrors.Mirror{
 					ID:            i * -1,
 					Name:          fmt.Sprintf("fallback%d", i),
-					HttpURL:       f.URL,
+					HttpURL:       httpURL,
+					HttpsURL:      httpsURL,
 					CountryCodes:  strings.ToUpper(f.CountryCode),
 					CountryFields: []string{strings.ToUpper(f.CountryCode)},
-					ContinentCode: strings.ToUpper(f.ContinentCode)})
+					ContinentCode: strings.ToUpper(f.ContinentCode),
+					SelectedProtocol: proto})
 			}
 			sort.Sort(mirrors.ByRank{Mirrors: mlist, ClientInfo: clientInfo})
 		} else {
diff --git a/mirrorbits.conf b/mirrorbits.conf
index aedacbc..82e7d8c 100644
--- a/mirrorbits.conf
+++ b/mirrorbits.conf
@@ -131,6 +131,8 @@
 ## Note: Mirrorbits will redirect to one of these mirrors based on the user
 ## location but won't be able to know if the mirror has the requested file.
 ## Therefore only put your most reliable and up-to-date mirrors here.
+## Note: Mirrorbits might redirect over HTTP or HTTPS depending on the request,
+## therefore the fallback mirrors should support both.
 # Fallbacks:
 #     - URL: http://fallback1.mirror/repo/
 #       CountryCode: fr
