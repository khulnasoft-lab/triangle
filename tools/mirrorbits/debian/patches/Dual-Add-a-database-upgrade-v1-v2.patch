From: Arnaud Rebillout <arnaudr@kali.org>
Date: Fri, 20 Oct 2023 11:50:43 +0700
Subject: Dual: Add a database upgrade (v1 -> v2)

This upgrade only changes the mirrors, ie. the MIRRORS key in the redis
database. It does the following:

- always: add new field `https`
- optionally: add new field `httpsUp` (if HTTPS URL and `up` exists)
- optionally: add new field `httpsDownReason` (if HTTPS URL and
  `excludeReason` exists)
- optionally: rename `up` -> `httpUp` (if HTTP URL and `up` exists)
- optionally: rename `excludeReason` -> `httpDownReason` (if HTTP URL
  and `excludeReason` exists)

In case it's not clear: the keys `up` and `excludeReason` are optional,
they might not exists in the database (in case a mirror was never
scanned or enabled). Hence we create their counterparts `https?Up` and
`https?DownReason` only if needed.
---
 core/database.go              |   2 +-
 database/upgrader/upgrader.go |   3 +
 database/v2/version2.go       | 176 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 180 insertions(+), 1 deletion(-)
 create mode 100644 database/v2/version2.go

diff --git a/core/database.go b/core/database.go
index 8aee1c4..c82926a 100644
--- a/core/database.go
+++ b/core/database.go
@@ -7,7 +7,7 @@ const (
 	// RedisMinimumVersion contains the minimum redis version required to run the application
 	RedisMinimumVersion = "3.2.0"
 	// DBVersion represents the current DB format version
-	DBVersion = 1
+	DBVersion = 2
 	// DBVersionKey contains the global redis key containing the DB version format
 	DBVersionKey = "MIRRORBITS_DB_VERSION"
 )
diff --git a/database/upgrader/upgrader.go b/database/upgrader/upgrader.go
index 2b68941..63a0001 100644
--- a/database/upgrader/upgrader.go
+++ b/database/upgrader/upgrader.go
@@ -6,6 +6,7 @@ package upgrader
 import (
 	"github.com/etix/mirrorbits/database/interfaces"
 	v1 "github.com/etix/mirrorbits/database/v1"
+	v2 "github.com/etix/mirrorbits/database/v2"
 )
 
 // Upgrader is an interface to implement a database upgrade strategy
@@ -18,6 +19,8 @@ func GetUpgrader(redis interfaces.Redis, version int) Upgrader {
 	switch version {
 	case 1:
 		return v1.NewUpgraderV1(redis)
+	case 2:
+		return v2.NewUpgraderV2(redis)
 	}
 	return nil
 }
diff --git a/database/v2/version2.go b/database/v2/version2.go
new file mode 100644
index 0000000..e40fd5e
--- /dev/null
+++ b/database/v2/version2.go
@@ -0,0 +1,176 @@
+// Copyright (c) 2023 Arnaud Rebillout
+// Licensed under the MIT license
+
+package v2
+
+import (
+	"strings"
+
+	"github.com/etix/mirrorbits/core"
+	"github.com/etix/mirrorbits/database/interfaces"
+	"github.com/gomodule/redigo/redis"
+	"github.com/pkg/errors"
+)
+
+// NewUpgraderV2 upgrades the database from version 1 to 2
+func NewUpgraderV2(redis interfaces.Redis) *Version2 {
+	return &Version2{
+		Redis: redis,
+	}
+}
+
+type Version2 struct {
+	Redis interfaces.Redis
+}
+
+type actions struct {
+	rename map[string]string
+}
+
+func (v *Version2) Upgrade() error {
+	a := &actions{
+		rename: make(map[string]string),
+	}
+
+	conn := v.Redis.UnblockedGet()
+	defer conn.Close()
+
+	// Erase previous work keys (previous failed upgrade?)
+	_, err := conn.Do("EVAL", `
+	local keys = redis.call('keys', ARGV[1])
+	for i=1,#keys,5000 do
+		redis.call('del', unpack(keys, i, math.min(i+4999, #keys)))
+	end
+	return keys`, 0, "V2_*")
+
+	if err != nil {
+		return err
+	}
+
+	err = v.UpdateMirrors(a)
+	if err != nil {
+		return err
+	}
+
+	// Start a transaction to atomically and irrevocably set the new version
+	conn.Send("MULTI")
+
+	for k, v := range a.rename {
+		conn.Send("RENAME", k, v)
+	}
+
+	conn.Send("SET", core.DBVersionKey, 2)
+
+	// Finalize the transaction
+	_, err = conn.Do("EXEC")
+
+	// <-- At this point, if any of the previous mutation failed, it is still
+	// safe to run a previous version of mirrorbits.
+
+	return err
+}
+
+func (v *Version2) UpdateMirrors(a *actions) error {
+	conn := v.Redis.UnblockedGet()
+	defer conn.Close()
+
+	// Get the list of mirrors
+	keys, err := redis.Strings(conn.Do("KEYS", "MIRROR_*"))
+	if err != nil && err != redis.ErrNil {
+		return errors.WithStack(err)
+	}
+
+	// Iterate on mirrors
+	for _, keyProd := range keys {
+		// Copy the key
+		key := "V2_" + keyProd
+		err := CopyKey(conn, keyProd, key)
+		if err != nil {
+			return errors.WithStack(err)
+		}
+
+		// Get the http url
+		url, err := redis.String(conn.Do("HGET", key, "http"))
+		if err != nil {
+			return errors.WithStack(err)
+		}
+
+		// Get the status. Note that the key might not exist if ever
+		// the mirror was never enabled or scanned successfully.
+		up, err := redis.Bool(conn.Do("HGET", key, "up"))
+		if err != nil && err != redis.ErrNil {
+			return errors.WithStack(err)
+		}
+		upExists := true
+		if err == redis.ErrNil {
+			upExists = false
+		}
+
+		// Get the excluded reason. As above: the key might not exist.
+		reason, err := redis.String(conn.Do("HGET", key, "excludeReason"))
+		if err != nil && err != redis.ErrNil {
+			return errors.WithStack(err)
+		}
+		reasonExists := true
+		if err == redis.ErrNil {
+			reasonExists = false
+		}
+
+		// Start a transaction to do all the changes in one go
+		conn.Send("MULTI")
+
+		if strings.HasPrefix(url, "https://") {
+			// Set HTTPS url, blank HTTP url
+			conn.Send("HSET", key, "https", url)
+			conn.Send("HSET", key, "http", "")
+			// Update up key if needed
+			if upExists {
+				conn.Send("HSET", key, "httpsUp", up)
+				conn.Send("HDEL", key, "up")
+			}
+			// Update reason key if needed
+			if reasonExists {
+				conn.Send("HSET", key, "httpsDownReason", reason)
+				conn.Send("HDEL", key, "excludeReason")
+			}
+		} else {
+			// Create empty HTTPS url field, leave HTTP url untouched
+			conn.Send("HSET", key, "https", "")
+			// Update up key if needed
+			if upExists {
+				conn.Send("HSET", key, "httpUp", up)
+				conn.Send("HDEL", key, "up")
+			}
+			// Update reason key if needed
+			if reasonExists {
+				conn.Send("HSET", key, "httpDownReason", reason)
+				conn.Send("HDEL", key, "excludeReason")
+			}
+		}
+
+		// Finalize the transaction
+		_, err = conn.Do("EXEC")
+		if err != nil {
+			return errors.WithStack(err)
+		}
+
+		// Mark the key for renaming
+		a.rename[key] = keyProd
+	}
+
+	return nil
+}
+
+func CopyKey(conn redis.Conn, src, dst string) error {
+	// NB: Redis COPY https://redis.io/commands/copy/ is only available
+	// since Redis 6.2, released in Feb 2021.  That's a bit too recent,
+	// so let's stick with the DUMP/RESTORE combination implemented in
+	// this function (and copy/pasted from the v1 database upgrade).
+	dmp, err := redis.String(conn.Do("DUMP", src))
+	if err != nil {
+		return err
+	}
+	_, err = conn.Do("RESTORE", dst, 0, dmp, "REPLACE")
+	return err
+}
+
